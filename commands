kubectl delete pod --grace-period=0 --force nginx



kubectl run redis --image=redis123 --dry-run=client -o yaml > redis-defination.yaml
kubectl apply -f redis-defination.yaml



apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: redis
  name: redis
spec:
  containers:
  - image: redis123
    name: redis
    resources: {}
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}





kubectl edit pod redis



kubectl get rs
kubetl get replicaset

kubectl describe rs new-replica-set | grep Image


kubectl explain replicaset | grep VERSION



apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: replicaset-1
spec:
  replicas: 2
  selector:
    matchLabels:
      tier: frontend
  template:
    metadata:
      labels:
        tier: frontend
    spec:
      containers:
      - name: nginx
        image: nginx




kubectl delete rs replicaset-1
kubectl edit replicaset new-replica-set


for var in $(kubectl get pods | grep "Image" | awk '{print $1}'); do kubectl delete pod $var; done




kubectl scale rs new-replica-set --replicas=5 or edit







kubectl get deployment
kubectl describe deployment | grep Image



kubectl get deployment/deploymentname -o yaml > deployment.yaml



---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: deployment-1
spec:
  replicas: 2
  selector:
    matchLabels:
      name: busybox-pod
  template:
    metadata:
      labels:
        name: busybox-pod
    spec:
      containers:
      - name: busybox-container
        image: busybox888
        command:
        - sh
        - "-c"
        - echo Hello Kubernetes! && sleep 3600
		
		
		
		
kubectl apply -f deployment-definition-1.yaml

kubectl create deployment httpd-frontend --image=httpd:2.4-alpine --replicas=3



kubectl delete all --all -n <namespace>





kubectl get pods -n research
kubectl run redis --image=redis -n finance
kubectl get pods --all-namespaces




kubectl get svc
kubectl get service
That is a default service created by Kubernetes at launch.


kubectl describe svc kubernetes - to see the target port, labels configured, end pointss attched
The range of valid ports is 30000-32767



apiVersion: v1
kind: Service
metadata:
  name: webapp-service
spec:
  type: NodePort
  ports:
    - targetPort: 8080
      port: 8080
      nodePort: 30080
  selector:
    name: simple-webapp
	
	
	
kubectl expose pod redis --port=6379 --name redis-service    >> by defaylt cluster ip
kubectl run httpd --image=httpd:apline --port=80 --expose    >> pod along with service
kubectl create deployment webapp --image=kodekloud/webapp-color --replicas=3



kubectl run custom-nginx --image=nginx --port=8080   >> container port 8080


kubectl create ns dev-ns


Manual sheduling


---
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  nodeName: node01      
  containers:
  -  image: nginx
     name: nginx
	 
	 


kubectl get pods --selector env=dev
kubectl get all --selector env=prod
kubectl get all --selector env=prod,bu=finance,tier=frontend



 kubectl describe node node01 
 >>>>>>>>>>>to see the tains on node
 kubectl taint nodes node01 spray=mortein:NoSchedule
 
 
 
 kubectl get nodes -o wide
 
 
 
 yaml file with tolerant:
 apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: bee
  name: bee
spec:
  containers:
  - image: nginx
    name: bee
    resources: {}
  tolerations:
  - key: spray
    value: mortein
    effect: NoSchedule
    operator: Equal  
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}





kubectl taint nodes controlplane node-role.kubernetes.io/master:NoSchedule-
>>to untaint a node




spec:                                      
  containers:                              
  - args:                                  
    - sleep                                
    - "1000"                               
    image: ubuntu                          
    imagePullPolicy: Always                
    name: cpu-stress                       
    resources:                             
      limits:                              
        cpu: "2"           
      requests:            
        cpu: "1"           
    terminationMessagePath: /dev/termination-log
    
    


State:          Waiting
      Reason:       CrashLoopBackOff
    Last State:     Terminated
      Reason:       OOMKilled
      
      
      
  
  
  kubectl get po elephant -o yaml > elephant.yaml
  
  
  
  
    resources:
      limits:
        memory: 10Mi
      requests:
        memory: 5Mi
	



kubectl get daemonsets --all-namespaces
kubectl describe daemonset kube-proxy --namespace=kube-system

Desired Number of Nodes Scheduled: 1
Current Number of Nodes Scheduled: 1
Number of Nodes Scheduled with Up-to-date Pods: 1
Number of Nodes Scheduled with Available Pods: 1
Number of Nodes Misscheduled: 0
Pods Status:  1 Running / 0 Waiting / 0 Succeeded / 0 Failed
Pod Template:


